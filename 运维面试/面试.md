### Linux

#### 软链接和硬链接的区别

- 软链接和硬链接是用于在文件系统中创建文件关联的方法
- 软链接类似于windows里面的快捷方式,包含了指向文件或者目录的路径,软链接可以跨越文件系统,目标文件删除的时候,软链接依旧存在,只是无法访问指向的文件
- 硬链接是文件系统的另一个实体,与目标文件共享相同的索引节点,硬链接实际上是目标文件的一个副本,删除目标文件不会影响到软链接.硬链接不能跨越文件系统,硬链接不能指向目录

#### 定时任务

用 cron 服务来创建和管理定时任务。cron 是一个守护进程，用于在指定的时间间隔内执行预定的命令或脚本。每个用户都有一个 crontab 文件，用于存储该用户的定时任务。你可以使用 `crontab -e` 命令编辑当前用户的 crontab 文件。

#### 查看进程

- ps命令显示当前正在运行的进程列表
- ps -ef 列出所有进程的详细信息
- top 实时显示进程资源使用情况和负载

#### 查看端口

- netstat 查看当前主机正在监听的端口
- netstat -tuln 显示所有tcp和udp的监听端口

#### 文件查找命令

- find
- locate
- which
- whereis

#### inode

用于表示文件或目录的元数据。每个文件和目录在文件系统中都有一个唯一的 Inode。Inode 包含了文件或目录的属性和指向数据块的指针

1. 文件类型：指示该 Inode 对应的是文件、目录、符号链接等类型。
2. 文件权限：指定了文件的访问权限，例如读、写和执行权限。
3. 文件所有者和所属组：标识了文件的所有者和所属组。
4. 文件大小：记录了文件的大小，以字节为单位。
5. 时间戳：包括文件的访问时间（atime）、修改时间（mtime）和状态改变时间（ctime）。
6. 链接计数：记录了指向该 Inode 的硬链接数量。
7. 数据块指针：指向存储文件内容的数据块的指针。对于较小的文件，Inode 直接存储数据块的指针；对于较大的文件，Inode 存储了间接指针、双重间接指针或三重间接指针，以便间接地寻址更多的数据块。

#### 权限控制

每个文件和目录都具有权限控制，用于确定谁可以对其进行读取、写入和执行操作。Linux 权限系统基于用户、用户组和其他用户的分类，并使用三种权限级别：读取权限、写入权限和执行权限

* `r`：读取权限。
* `w`：写入权限。
* `x`：执行权限。
* `-`：表示未设置相应的权限。

权限组合

- rwxrwxrwx: 777代表所有者、所属组和其他用户都具有读取、写入和执行权限。
- rw-r--r--: 644所有者具有读取和写入权限，而所属组和其他用户只具有读取权限。

权限组

* 所有者权限：文件或目录的所有者拥有特定的权限。
* 所属组权限：文件或目录所属的用户组拥有特定的权限。
* 其他用户权限：除所有者和所属组之外的其他用户拥有特定的权限。

#### 查看磁盘使用情况

- `df` 命令：`df` 命令用于查看文件系统的磁盘空间使用情况。使用该命令可以获取整个系统或指定文件系统的磁盘使用情况统计信息
- du 命令：du 命令用于估算文件和目录的磁盘使用情况。它可以递归地计算目录及其子目录下的文件大小，并提供总体的磁盘使用情况

### 网络

#### 如何检查端口是否是通的

- 使用 telnet 命令（适用于 TCP 端口）
- 使用 nc 命令（也称为 netcat 命令

#### 五层模型协议

- 物理层: 负责在物理介质上传输比特流，提供物理连接和电信号传输
- 数据链路层: 在物理层上提供可靠的数据传输，将比特流划分为数据帧，并处理错误检测和纠正。---以太网协议
- 网络层: 负责为数据包选择最佳路径，进行逻辑寻址和路由选择。---ip协议
- 传输层: 提供端到端的通信服务，确保数据在源和目的地之间可靠传输 --- tcp、udp
- 应用层: 提供网络应用程序与用户之间的接口，处理特定的应用协议和数据 --- http、smtp

#### 子网掩码

用于划分 IP 地址的网络地址和主机地址的一个32位二进制数。它与 IP 地址结合使用，用于确定网络地址和主机地址的划分边界。子网掩码中的连续的1表示网络地址的部分，连续的0表示主机地址的部分。子网掩码通过与 IP 地址进行逻辑与（AND）运算，将 IP 地址划分为网络地址和主机地址。网络地址用于标识特定的网络，而主机地址用于标识网络中的具体主机。

### docker

#### 多阶段编译

1. 创建多个构建阶段：在Dockerfile中使用多个 `FROM`语句创建多个阶段。每个阶段可以基于不同的基础镜像，并安装所需的构建工具和依赖项。
2. 分割构建过程：在每个阶段中，使用适当的指令（如 `RUN`、`COPY`等）执行构建步骤。可以在每个阶段中进行编译、依赖项安装、拷贝文件等操作。
3. 复制文件：在每个阶段的最后，使用 `COPY --from=<阶段名称>`指令将构建所需的文件从之前的阶段复制到当前阶段。这样可以避免将不必要的构建工具和文件包含在最终的镜像中。
4. 定义最终阶段：最后一个阶段可以是一个最小的基础镜像，只包含应用程序和必要的运行时依赖项。

```
FROM golang:alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD ["./app"]
```

#### docker中的网络

1. 默认桥接网络（Bridge Network）：默认情况下，Docker容器使用桥接网络，容器可以通过桥接网络接口与主机和其他容器进行通信。每个容器都分配了一个唯一的IP地址，并可以使用容器名称或IP地址进行通信。
2. 主机网络（Host Network）：使用主机网络模式，容器与主机共享网络命名空间，容器可以直接使用主机的网络接口和IP地址，从而绕过Docker的网络堆栈。这种模式下，容器与主机之间的网络性能更好，但容器之间的隔离性较差。
3. none网络（None Network）：在none网络模式下，容器没有与之关联的网络接口。这种模式适用于不需要网络连接的特殊容器，如批处理任务或与网络无关的应用程序。
4. Overlay网络（Overlay Network）：Overlay网络用于在多个Docker主机之间创建跨主机的容器网络。它使用VXLAN（Virtual Extensible LAN）或类似的技术，在不同的主机上创建逻辑网络，使容器可以透明地跨主机通信。空

### k8s

#### statefulset和deployment的区别

1. * Deployment：Deployment控制器用于管理无状态应用，这意味着应用程序实例之间是可以互相替换的，没有持久的标识。Deployment可以水平扩展、回滚和更新应用程序副本，但对于应用程序实例的标识不保持状态。
   * StatefulSet：StatefulSet控制器用于管理有状态应用，这些应用程序实例具有持久的标识。每个应用程序实例都有一个唯一的标识符和稳定的网络标识。StatefulSet确保应用程序实例的有序部署、伸缩和终止，以及与持久化存储的正确连接和管理。
2. - Deployment：Deployment创建的Pod通常没有稳定的网络标识。Pod的IP地址和DNS名称在每次重启或重新调度时可能会发生变化。因此，无状态应用不依赖于Pod的标识符，可以在任何Pod上运行。
   - StatefulSet：StatefulSet创建的Pod具有稳定的网络标识和唯一的标识符。Pod的标识符基于其在StatefulSet中的顺序，例如，Pod名称可以是 `<StatefulSetName>-<ordinal>`的形式（例如，web-0、web-1等）。这些标识符保持不变，即使Pod重新启动或重新调度。
3. - Deployment：Deployment不提供内建的持久性支持，也不保证应用程序实例的有序部署。应用程序实例可以在任何Pod上启动和停止，没有特定的顺序。
   -  StatefulSet：StatefulSet可以配置和管理应用程序实例的持久化存储。它确保应用程序实例的有序部署和终止，并根据配置和状态管理持久化存储的卷。这对于需要有序启动和访问稳定存储的有状态应用程序非常重要。

#### 持久化存储

1. HostPath：HostPath类型的PV使用宿主机上的文件系统路径作为存储卷。它将宿主机上的目录或文件挂载到Pod中，适用于测试和开发环境，但不适用于生产环境，因为宿主机上的数据不具备迁移和弹性的特性。
2. EmptyDir：EmptyDir类型的PV是在Pod生命周期中临时存在的存储卷。它在Pod创建时创建，并与Pod一起删除。EmptyDir通常用于容器之间共享临时数据，但不适用于需要数据持久性的场景。
3. NFS：NFS（Network File System）是一种基于网络的文件系统协议，可以将存储卷挂载到Pod中。使用NFS类型的PV，可以将NFS服务器上的目录挂载到Pod中，实现数据的持久性和共享。
4. PersistentVolumeClaim（PVC）：PersistentVolumeClaim是一种声明式的方式，用于请求特定类型和大小的持久化存储卷。PVC与PV是一对一关系，PVC请求所需的存储资源，而PV提供实际的存储资源。通过PVC，可以将各种类型的存储卷（如NFS、AWS EBS、Azure Disk等）动态地绑定到Pod中。

#### service

1. ClusterIP：ClusterIP类型的Service在集群内部提供了一个虚拟的IP地址，只能从集群内部访问。它通过内部的kube-proxy组件将请求负载均衡到后端Pod。
2. NodePort：NodePort类型的Service在每个节点上公开了一个静态端口，可以通过节点的IP地址和该端口从集群外部访问Service。请求会通过NodePort转发到后端Pod。NodePort类型同时也会创建一个ClusterIP，可以通过ClusterIP在集群内部访问Service。
3. LoadBalancer：LoadBalancer类型的Service通过云提供商的负载均衡器（如AWS ELB、Azure Load Balancer）创建一个外部负载均衡器，将请求分发到集群中的Service。这种类型的Service通常用于公共云环境，可以从公共网络访问Service。

#### 探针probe

1. Liveness Probe（存活探针）：Liveness Probe用于检查容器是否仍然运行正常。如果Liveness Probe失败（即容器被认为不健康），Kubernetes会自动重启该容器。Liveness Probe常用于检测容器内部的应用程序是否正常运行，例如通过发送HTTP请求到容器的健康检查端点或检查容器内进程的状态。
2. Readiness Probe（就绪探针）：Readiness Probe用于检查容器是否已经准备好接收流量。如果Readiness Probe失败（即容器被认为不就绪），Kubernetes会将该容器从Service的负载均衡中剔除，不再将流量转发给该容器。Readiness Probe常用于在容器启动过程中执行一些初始化操作，并确保容器已经完全就绪，可以接收请求。
3. Startup Probe（启动探针）：Startup Probe用于检查容器是否正在启动中。与Liveness Probe和Readiness Probe不同，Startup Probe在容器启动过程中进行检查，而不是在容器已经运行的状态下。如果Startup Probe失败，Kubernetes可以选择等待一段时间，继续检查容器的启动状态，或者重启容器。
